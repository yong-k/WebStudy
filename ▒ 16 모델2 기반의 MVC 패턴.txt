	★★★★★★★★★
■■■ 모델2 기반의 MVC 패턴 ■■■
       -----        --------
       └→ 방식     └→ 디자인패턴 (IT분야에서의 수학 공식 같은 것)
	★★★★★★★★★

→ spring 까지 이 얘기 반복해서 할 것이다.
   거의 마지막에 배울 spring framework 에서 가장 중요한 개념이 MVC 패턴이다.
   spring MVC 배우고 교육과정 마칠 것이다.


○ 개요
   
   MVC 패턴에서 MVC 는 각각 Model, View, Controller 를 의미하는 것으로
   Model 은 데이터 또는 기본 기능(업무 로직)을 말하며,
   View 는 유저 인터페이스를 말한다.
   이 두 가지는 시스템 개발에 있어서 반드시 필요한 부분이다.

		---------------------------------------------------------------------	
	  ①
     │
     └→ 프로그램 만드는데 있어서 모델과 뷰는 꼭 있어야 하지만, 컨트롤러는 없어도 된다.
	  if ) 레스토랑을 차렸다고 가정하자
		주방장     → Model
		홀서빙알바 → View
		owner인 우리 입장에서는 Model(주방장)이 더 중요하다.
		홀서빙알바는 10년 근속해야지라는 마음으로 알바하는 사람 없다.
		알바는 자주자주 바뀐다.
		그런데 controller 없이, model과 view만 가지고 어플리케이션 만들면,
		view는 클라이언트한테 보여지는 것이고, 그때그때 자주 바뀐다.
		업무 로직(model)은 바꾸려면 비용,리소스 되게 많이 든다.
		그러다보니, view는 2달에 한 번 바꾼다면, model은 20년에 한 번씩 바꾼다.
		model과 view를 자주자주 만나게 했더니, 
		알바(view)가 주문받고 주방장(model)한테 가서 얘기하면서 윙크하고
		둘이 눈맞음 ㅎㅎ
		알바가 2달하고 관둔다고 하니까, 
		주방장도 와서 '이대로 못보낸다. 저도 그만두겠다' 이런식이 되어버린다..

		→ owner 입장에서...일하는 동안 둘이 못 만나게 해야 한다.
		   주방장은 주방에서 못나오게, 홀서빙 알바는 주방에 못들어가게 한다.
	 	   둘이 목소리도 들을 일 없게, 만날일 없게 해야한다.

		→ 알바가 주문 받으면 controller 한테 가서 포스기에 뙇 찍으면,
		   주방에서는 주방장이 모니터로 확인 가능하게 되는 상황
		 
		이렇게 바꿨더니, 홀에서 알바 그만두더라도, 주방에서는 그만둔지도 모름
		→ 그 역할을 수행하는 게 controller
		
		<controller 의 1차적 존재목적>
		→ view와 model이 뒤섞이지 않게, 서로 만나지 않도록, 의존하지 않도록
		   view 또는 model이 바뀌더라도 깔끔하게 각자만 바뀔 수 있도록
		   둘 사이에 controller 둬서 둘이 못만나게 한다!
		---------------------------------------------------------------------
		②

		우리가 여태까지 코딩한 방식에 의하면
		우리가 각자 다 jsp 파일이라고 한다면,
		쌤이 우리반을 관리하는 관리자. 

		지금까지는!!
		클라이언트가 문 벌컥열고
		한충희.jsp(view) 나와 하고 멱살잡고 끌고나가서 벽돌 옮기라고 하면
		그 일 하고 들어오고
		홍은혜.jsp 나와 하면 질질 끌려가서 땅굴파라 하면 
		일하고 들어오는 방식이었다. 
		→ 주소에 /~~.jsp 하는 방식으로 호출했으니까
		   /한충희.jsp, /홍은혜.jsp  이런식으로
		→ 관리자가 제대로 관리하기 힘듦...
		   와서 충희 찾으면 없고, 은혜찾으면 없고 이런상황

		이제는 그렇게 하지 않는것. 관리자(controller, 쌤) 열받음
		'왜 우리반 애들 이름불러서 막 데리고 가냐'
		다음부터는 불러가기 전에 관리자한테 먼저 말해라
		'벽돌 옮겨야되는데 벽돌 잘 옮길 수 있는 인물 한 명 차출해주세요.'
		하면 관리자가 '음 상기가 잘 옮기지 갔다와'
		하고 판단하고 골라서 보내주는거!
		→ 이게 MVC
		---------------------------------------------------------------------

		- Model과 View의 LifeCycle 다름. 서로 교체주기가 다르다!
		  타이어 고장났다고 핸들도, 엔진도 바꾸는 거 아닌 거 처럼!	

		- 클라이언트가 직접 자기 상황에 맞게 view 데리고 가는게 아니라,
		  요청하면, controller가 거기에 맞는 아이 고려해서 view 출동시킴

		- 관리자가 관리하기 수월해짐
		---------------------------------------------------------------------
		

   MVC 패턴은 C 패턴이라고 불러도 괜찮을만큼 
   한 마디로 말해 Controller 라는 레이어 계층을 두는 것이 가장 중요하다.
   즉, Graphical User Interface 를 활용하는 과정에서
   Model 과 View 계층 사이에
   Controller 계층을 만들어 사용할 수 있도록 하는 것이다.

   이렇게 필수적인 두 계층(Model, View) 사이에
   필수적이지 않은 다른 계층(Controller)을 두는 이유는
   두 계층(Model 과 View)이 직접적으로 결합되는 것을 막는 것으로
		            ================================
   Controller 계층은 Model 계층과 View 계층 사이에서 결합을 막아준다.
   Model 과 View 의 직접적인 결합은 이 둘을 함께 바뀌도록 만들어 버린다.
   이것을 Controller 계층이 막아준다는 것이다.
   따라서... Controller 계층의 로직은 매우 간단하게 설계해야 한다.


	┌→ Model1, Model2 는 있어도 MVC1, MVC2 는 없다.
	│   MVC는 하나밖에 없다.
	│
○ Web Application 에서의 MVC 구조

   JSP 는 로직과 프리젠테이션을 알맞게 구분하기 위해
   Model2 구조를 지원하고 있으며,
   Model2 구조의 개념과 구현 방법, 장단점 등을 이해하고
   적용시키는 것이 중요하다.

					                  View
				                        --------
		      ┌→클라이언트가 와서 문 벌컥열고 은혜.jsp 나와! 하는거
   - Model1 구조 (→ 클라이언트 요청이 진입하는 지점 : View)
     모델1 구조는 일반적으로 JSP 페이지만으로 구성되어 있는 구조를 말한다.
     즉, JSP 페이지에서 동적인 부분(로직 부분)은 스크립트릿으로 처리하고
     그 외 나머지 부분은 템플릿으로 처리하는 구조인 것이다.
     모델1과 모델2의 가장 큰 차이점은
     =================================
     클라이언트의 요청이 진입하는 지점이 다르다는 것이다.
     =====================================================
	└→ 모델1의 클라이언트 요청 진입 지점 : View 
	     모델2의 클라이언트 요청 진입 지점 : Controller

     ·장점
       개발 시간이 단축된다.
       단순한 페이지의 흐름을 바탕으로 MVC 구조에 대한 
       추가적인 이해가 필요하지 않다. (→ 우리가 지금까지 계속 해오던 방식이 이거)

     ·단점
       HTML, Javascript, JSP 로직(스크립릿영역)이 한 페이지에 작성되어
       어플리케이션이 복잡해질수록 유지보수가 힘들어진다. (거의 불가능)
       디자이너와 개발자 사이에 밀접하고 원활한 소통이 요구된다.
       =========================================================
	└→ Model1 에서 Model2 로 넘어온 가장 큰 계기가 될 수 있다.


   - Model2 구조
     모델2 구조는 JSP 와 Servlet 그리고 JavaBean 컴포넌트를 함께 사용하며,
     모델2의 클라이언트의 진입하는 지점은 컨트롤러이며,
	     =====================================
     대부분의 웹 어플리케이션의 컨트롤러는 Servlet 이 담당한다.

     ·장점
       로직과 프리젠테이션의 분리로 인해 어플리케이션이 명료해지고
       유지보수나 확장이 용이하다.
       디자이너와의 작업이 분리되어 있기 때문에
       업무 진행이 원활하고 책임의 소재가 명확하다.
       ------------------   ======================
	└→ 이건 잘 		   ★★★		
	 모르겠지만,,ㅎㅎ

     ·단점
       개발 초기에 아키텍처 디자인을 위한 분석... 구성... 등의
       시간 소요로 개발 기간이 전체적으로 늘어난다.
       MVC 구조에 대한 개발자들의 이해를 필요로 하며,
       이에 대한 이유로 사전 교육 기간 등이 소요될 수 있다.
	│
	└→  현재 2022년 기준으로 MVC 이해못한 개발자 없다.
	      현재 진행하고 있는 모든 프로젝트는 MVC 기반으로 돌아가고 있으므로
	      당연히 알아야 한다!!


※ MVC(Model2) 구조
   
   - 모델(Model)
     비즈니스 로직과 관련된 부분만 처리
     데이터베이스 관련 로직 구현
     Java Beans

   - 뷰(View)
     사용자에게 알맞은 화면을 보여주는 역할을 수행
     JSP

   - 컨트롤러(Controller)
     어플리케이션의 흐름 제어나 사용자의 요청 구현
     사용자 인증, 보안 설정, 전체 어플리케이션에 공통으로 영향을 주는 요소 구현
     사용자의 요청에 대해 알맞은 모델 사용
     사용자에게 보여줄 뷰 선택
     Servlet
	→ 사실상 그렇게 크게 하는 일은 없다! 
	   ex) 일은 내가 다했는데, 자기가 한 걸로 이름 올리는 상사 같은 느낌?


※ MVC(Model2) 구현

   - JSP 기반의 웹 어플리케이션에서 Controller 에 포함되어야 할 작업
     ·웹브라우저(클라이언트)의 요청을 받는다.
     ·웹브라우저(클라이언트)가 요구하는 작업을 분석한다.
     ·요청한 작업을 처리하는 비즈니스 로직을 수행하는 
       모델(Model:JavaBean)을 사용한다.
     ·처리 결과를 request 또는 session 에 저장한다.
     ·적절한 뷰(View:JSP)를 선택하여
       해당 뷰로 포워딩(forwarding)한다.


   - JSP 기반의 웹 어플리케이션에서 View 에 포함되어야 할 작업
     ·서블릿에서 dispatcher.forward(request, response) 로
       해당 JSP 페이지와 request, response 를 공유한 경우
       해당 JSP 페이지에서 request.getAttribute("result")와 같이
       사용하여 결과를 화면에 표현한다.


   - JSP 기반의 웹 어플리케이션에서 Model 에 포함되어야 할 작업
     ·컨트롤러(Controller)의 요청을 받는다.
     ·비즈니스 로직을 처리한다.
     ·처리한 비즈니스 로직의 결과를 컨트롤러(Controller)로 반환한다.


----------------------------------------------------------------------------------

○ MVC 관련 실습 1

- project : WebApp24
  
  ·web.xml		→ URL 매핑
  ·MVCBegin.java	→ Controller 역할 (서블릿 클래스)
  ·MVCBegin.jsp	→ View 역할 (JSP 페이지)

- 사용자 최초 요청 주소 → 『~.jsp』 직접 불러서 쓰겠다는 형태 아니다.
http://localhost:8090/WebApp24/mvcbegin
			      ---------
				→ 이 요청이 controller 로 진입한다.

→ 사용자가 『/mvcbegin』으로 주소 요청하면
   web.xml 움찔하며, <url-pattern>에 /mvcbegin 쪽으로 가서 <servlet-name> 확인
   servlet-name 같은 <servlet> 찾아서 <servlet-class> 로 가서 객체 생성한다.
  ·
---------------------------------------------------------------
○ MVC 관련 실습 2

- project : WebApp25
  
  ·web.xml		→ URL 매핑
  ·MVCTest01.java	→ Controller 역할 (서블릿 클래스)
  ·MVCTest01.jsp	→ View 역할 (JSP 페이지)

- 사용자 최초 요청 주소 
http://localhost:8090/WebApp25/mvctest01



webapp25 (순서대로 파일 생성하고 진행해보자)
①web.xml
②com.svt → ServletSample 복붙하고 이름 MVCTest01.java
③webcontent → MVCTest01.jsp


- 클라이언트가 MCVTest01.jsp라고 주소창에 직접 
  view 입력해도 페이지 뜨지 않게 하기 위한 작업
web-inf>view 폴더 만들어서 MVCTest01.jsp 옮기고	
	밖에 있던거 제거!
>MVCTest01.java 에 requestDispatcher 주소 바꿔주기

---------------------------------------------------------------
○ MVC 관련 실습 3

- project : WebApp25
  
  ·1) web.xml		→ URL 매핑
  ·2) MVCTest02.java	→ Controller 역할 (서블릿 클래스)
  ·4) MVCTest02.jsp	→ View 역할 (JSP 페이지)  
			→ com.test 패키지
  ·3) MVCTest02Model.java → Model 역할 (일반 자바 클래스)

- 사용자 최초 요청 주소 
http://localhost:8090/WebApp25/mvctest02


→ 볼륨감 커지더라도 확장되어도, 이 구조 변하지 않으니
   꼼꼼하게 분석하고 이해하기
→ DBConn 뚝딱 만들듯이,
   이거 다 뚝딱 구성할 수 있어야 한다!!!

---------------------------------------------------------------

○ 폼(form) 데이터 전송 및 수신 과정 비교

   ※ MVC 패턴 적용 이전 단계와 MVC 패턴 적용 이후 단계를
      반드시 비교하여 이해할 수 있도록 할 것

   - A
    ·project : WebApp26

    ·(전송) HelloSend01.html
    ·(수신) HelloReceive01.jsp

    ·사용자 최초 요청 주소 
      http://localhost:8090/WebApp26/HelloSend01.html

     → html로 보내고, jsp로 받는 구조


   - B
    ·project : WebApp27

    ·(전송) HelloSend02.html
    ·(수신) HelloReceive02.java → servlet 으로 처리하게 하기 위해 web.xml 건드림
		└→ com.test.svt 패키지에 생성
    ·web.xml 

    ·사용자 최초 요청 주소
      http://localhost:8090/WebApp27/HelloSend02.html

     ★★★
   - C (우리는 이 형태로 가게 될 것이다!!)
	A,B와 C가 어떻게 다른지 잘 확인해야 한다.
    ·project : WebApp28

    ·HelloSend03.html (클라이언트가 얘 직접 호출못하게 할거임)	
      → web-inf > view 폴더안에 생성
    ·HelloSend03Controller.java
      → com.svt에 servletSample 열어서 extends부터 끝까지 복붙
    ·HelloReceive03Controller.java
    ·HelloReceive03Model.java
    ·HelloReceive03.jsp
	앞에 HelloSend03.html은 html인데 얘는 왜 jsp로 만듦?
  	→ 얘는 컨트롤러로부터 뭘 받아야 하기 때문에 .jsp 파일로 만든다.
    ·web.xml (서블릿 등록)

    ·사용자 최초 요청 주소
      http://localhost:8090/WebApp28/hello

---------------------------------------------------------------